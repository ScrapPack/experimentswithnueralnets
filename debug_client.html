<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>PC Gamestate — Debug Client</title>
<style>
  body { background: #1a1a2e; color: #eee; font-family: monospace; margin: 20px; }
  h1 { color: #e94560; font-size: 18px; }
  #grid { display: grid; grid-template-columns: repeat(10, 42px); gap: 2px; margin: 16px 0; }
  .cell { width: 40px; height: 40px; border: 1px solid #333; cursor: pointer;
          display: flex; align-items: center; justify-content: center;
          font-size: 9px; transition: background 0.15s; }
  .cell:hover { border-color: #e94560; }
  #log { background: #0f0f23; padding: 10px; max-height: 250px; overflow-y: auto;
         font-size: 11px; line-height: 1.5; border: 1px solid #333; margin-top: 12px; }
  .info { color: #888; font-size: 12px; margin: 8px 0; }
  button { background: #e94560; color: white; border: none; padding: 6px 16px;
           cursor: pointer; font-family: monospace; margin-right: 8px; }
  button:hover { background: #c73650; }
</style>
</head>
<body>
<h1>Predictive Coding Gamestate Engine — Debug View</h1>
<p class="info">Left-click = strike (density). Right-click = heat (thermal). Stone (left, dark) is brittle. Sand (right, gold) is weak.</p>
<div id="grid"></div>
<p class="info">
  Strikes: <span id="strikes">0</span> |
  Heats: <span id="heats">0</span> |
  Destroyed: <span id="destroyed">0</span> |
  Weakened: <span id="weakened">0</span> |
  Hot (&gt; −0.8): <span id="hot">0</span>
</p>
<button onclick="resetGrid()">Reset</button>
<div id="log"></div>

<script>
const W = 10, H = 10, URL = "http://127.0.0.1:5001";
let strikes = 0, heats = 0, busy = false, destroyedSet = new Set();
let materials = [];  // "stone" or "sand" per cell, fetched once
const GRID_CELLS = W * H;  // 100

const grid = document.getElementById("grid");
const cells = [];
for (let y = 0; y < H; y++) {
  for (let x = 0; x < W; x++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.style.background = "#2a6e2a";
    cell.onclick = () => doStrike(x, y);
    cell.oncontextmenu = (e) => { e.preventDefault(); doHeat(x, y); };
    grid.appendChild(cell);
    cells.push(cell);
  }
}

function log(msg) {
  const el = document.getElementById("log");
  el.innerHTML += msg + "<br>";
  el.scrollTop = el.scrollHeight;
}

function updateGrid(state) {
  let weakened = 0, hotCount = 0;
  for (let i = 0; i < GRID_CELLS && i < cells.length; i++) {
    // Density: indices 0–99.
    const dv = Math.max(-1, Math.min(1, state[i]));
    // Thermal: indices 100–199.
    const hv = (i + GRID_CELLS < state.length)
      ? Math.max(-1, Math.min(1, state[i + GRID_CELLS]))
      : -1;
    const t = (1.0 - dv) / 2.0;  // 0=solid, 1=air
    const mat = materials[i] || "stone";
    let r, g, b;
    if (t > 0.9) {
      r = 135; g = 200; b = 235;
    } else if (mat === "stone") {
      r = 60 + t * 120;
      g = 65 + t * 120;
      b = 85 + t * 130;
    } else {
      r = 190 + t * 40;
      g = 160 + t * 60;
      b = 80 + t * 100;
    }
    // Heat overlay: blend toward fiery orange (255, 76, 0).
    if (hv > -0.8) {
      const ht = (hv + 1.0) / 2.0;   // 0=cold, 1=hot
      const blend = ht * 0.8;         // max 80% blend
      r = r * (1.0 - blend) + 255 * blend;
      g = g * (1.0 - blend) + 76 * blend;
      b = b * (1.0 - blend) + 0 * blend;
      hotCount++;
    }
    r = Math.round(r); g = Math.round(g); b = Math.round(b);
    cells[i].style.background = `rgb(${r},${g},${b})`;
    // Show density value; append heat if hot.
    cells[i].textContent = hv > -0.8
      ? `${dv.toFixed(1)}|${hv.toFixed(1)}`
      : dv.toFixed(2);
    cells[i].style.color = t > 0.5 ? "rgba(0,0,0,0.5)" : "rgba(255,255,255,0.5)";
    if (dv < 0.95) weakened++;
  }
  document.getElementById("weakened").textContent = weakened;
  document.getElementById("destroyed").textContent = destroyedSet.size;
  document.getElementById("hot").textContent = hotCount;
}

async function fetchState() {
  try {
    const r = await fetch(URL + "/get_state");
    const data = await r.json();
    // /get_state returns {"state": [...], "materials": [...]}
    materials = data.materials;
    updateGrid(data.state);
    const stoneCount = materials.filter(m => m === "stone").length;
    log(`Initial state loaded — ${stoneCount} stone + ${100 - stoneCount} sand — ${data.state.length} dims`);
  } catch(e) { log("ERROR: " + e.message); }
}

async function doStrike(x, y) {
  if (busy) return;
  busy = true;
  const idx = y * W + x;
  destroyedSet.add(idx);
  log(`Strike (${x}, ${y}) ...`);
  try {
    const r = await fetch(URL + "/strike", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({x, y})
    });
    const state = await r.json();
    strikes++;
    document.getElementById("strikes").textContent = strikes;
    updateGrid(state);
    const densitySlice = state.slice(0, GRID_CELLS);
    log(`  → density[${x},${y}]=${state[idx].toFixed(3)}  min_d=${Math.min(...densitySlice).toFixed(3)}`);
  } catch(e) { log("ERROR: " + e.message); }
  busy = false;
}

async function doHeat(x, y) {
  if (busy) return;
  busy = true;
  const idx = y * W + x;
  log(`Heat (${x}, ${y}) ...`);
  try {
    const r = await fetch(URL + "/heat", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({x, y})
    });
    const state = await r.json();
    heats++;
    document.getElementById("heats").textContent = heats;
    updateGrid(state);
    const thermalVal = state[idx + GRID_CELLS];
    log(`  → thermal[${x},${y}]=${thermalVal.toFixed(3)}`);
  } catch(e) { log("ERROR: " + e.message); }
  busy = false;
}

async function resetGrid() {
  try {
    const r = await fetch(URL + "/reset", {method: "POST"});
    const state = await r.json();
    strikes = 0;
    heats = 0;
    destroyedSet.clear();
    document.getElementById("strikes").textContent = 0;
    document.getElementById("heats").textContent = 0;
    updateGrid(state);
    log("--- RESET ---");
  } catch(e) { log("ERROR: " + e.message); }
}

fetchState();
</script>
</body>
</html>
