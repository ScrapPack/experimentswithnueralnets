<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>PC Gamestate — Debug Client</title>
<style>
  body { background: #1a1a2e; color: #eee; font-family: monospace; margin: 20px; }
  h1 { color: #e94560; font-size: 18px; }
  #grid { display: grid; grid-template-columns: repeat(10, 42px); gap: 2px; margin: 16px 0; }
  .cell { width: 40px; height: 40px; border: 1px solid #333; cursor: pointer;
          display: flex; align-items: center; justify-content: center;
          font-size: 9px; transition: background 0.15s; }
  .cell:hover { border-color: #e94560; }
  #log { background: #0f0f23; padding: 10px; max-height: 250px; overflow-y: auto;
         font-size: 11px; line-height: 1.5; border: 1px solid #333; margin-top: 12px; }
  .info { color: #888; font-size: 12px; margin: 8px 0; }
  button { background: #e94560; color: white; border: none; padding: 6px 16px;
           cursor: pointer; font-family: monospace; margin-right: 8px; }
  button:hover { background: #c73650; }
  .tick-active { color: #4ecdc4; }
  .tick-paused { color: #e94560; }
</style>
</head>
<body>
<h1>Predictive Coding Gamestate Engine — Debug View</h1>
<p class="info">Left-click = strike. Right-click = heat. Stone (dark) | Wood (brown, flammable) | Ice (cyan, melts).</p>
<div id="grid"></div>
<p class="info">
  Strikes: <span id="strikes">0</span> |
  Heats: <span id="heats">0</span> |
  Destroyed: <span id="destroyed">0</span> |
  Weakened: <span id="weakened">0</span> |
  Hot (&gt; −0.8): <span id="hot">0</span> |
  Ticks: <span id="ticks">0</span>
</p>
<button onclick="resetGrid()">Reset</button>
<button id="tickToggle" onclick="toggleTick()">Pause Tick</button>
<span id="tickStatus" class="tick-active">⏱ ticking (0.5 s)</span>
<div id="log"></div>

<script>
const W = 10, H = 10, URL = "http://127.0.0.1:5001";
let strikes = 0, heats = 0, ticks = 0, busy = false, tickBusy = false;
let destroyedSet = new Set();
let materials = [];  // "stone", "wood", or "ice" per cell, fetched once
const GRID_CELLS = W * H;  // 100

// Tick metronome (Phase 11)
let tickInterval = null;
let tickPaused = false;

const grid = document.getElementById("grid");
const cells = [];
for (let y = 0; y < H; y++) {
  for (let x = 0; x < W; x++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.style.background = "#2a6e2a";
    cell.onclick = () => doStrike(x, y);
    cell.oncontextmenu = (e) => { e.preventDefault(); doHeat(x, y); };
    grid.appendChild(cell);
    cells.push(cell);
  }
}

function log(msg) {
  const el = document.getElementById("log");
  el.innerHTML += msg + "<br>";
  el.scrollTop = el.scrollHeight;
}

function updateGrid(state) {
  let weakened = 0, hotCount = 0;
  for (let i = 0; i < GRID_CELLS && i < cells.length; i++) {
    // Density: indices 0–99.
    const dv = Math.max(-1, Math.min(1, state[i]));
    // Thermal: indices 100–199.
    const hv = (i + GRID_CELLS < state.length)
      ? Math.max(-1, Math.min(1, state[i + GRID_CELLS]))
      : -1;
    const t = (1.0 - dv) / 2.0;  // 0=solid, 1=air
    const mat = materials[i] || "stone";
    let r, g, b;
    if (t > 0.9) {
      r = 135; g = 200; b = 235;           // sky blue (air)
    } else if (mat === "stone") {
      r = 60 + t * 120;                    // dark slate → light gray
      g = 65 + t * 120;
      b = 85 + t * 130;
    } else if (mat === "wood") {
      r = 101 + t * 100;                   // warm brown → lighter brown
      g = 67 + t * 100;
      b = 33 + t * 80;
    } else {                                // ice: pale cyan → white
      r = 175 + t * 75;
      g = 238 + t * 12;
      b = 238 + t * 12;
    }
    // Heat overlay: blend toward fiery orange (255, 76, 0).
    if (hv > -0.8) {
      const ht = (hv + 1.0) / 2.0;   // 0=cold, 1=hot
      const blend = ht * 0.8;         // max 80% blend
      r = r * (1.0 - blend) + 255 * blend;
      g = g * (1.0 - blend) + 76 * blend;
      b = b * (1.0 - blend) + 0 * blend;
      hotCount++;
    }
    r = Math.round(r); g = Math.round(g); b = Math.round(b);
    cells[i].style.background = `rgb(${r},${g},${b})`;
    // Show density value; append heat if hot.
    cells[i].textContent = hv > -0.8
      ? `${dv.toFixed(1)}|${hv.toFixed(1)}`
      : dv.toFixed(2);
    cells[i].style.color = (t > 0.5 || mat === "ice") ? "rgba(0,0,0,0.5)" : "rgba(255,255,255,0.5)";
    if (dv < 0.95) weakened++;
  }
  document.getElementById("weakened").textContent = weakened;
  document.getElementById("destroyed").textContent = destroyedSet.size;
  document.getElementById("hot").textContent = hotCount;
}

async function fetchState() {
  try {
    const r = await fetch(URL + "/get_state");
    const data = await r.json();
    // /get_state returns {"state": [...], "materials": [...]}
    materials = data.materials;
    updateGrid(data.state);
    const counts = {};
    materials.forEach(m => counts[m] = (counts[m] || 0) + 1);
    const parts = Object.entries(counts).map(([k, v]) => `${v} ${k}`).join(" + ");
    log(`Initial state loaded — ${parts} — ${data.state.length} dims`);
  } catch(e) { log("ERROR: " + e.message); }
}

async function doStrike(x, y) {
  if (busy) return;
  busy = true;
  const idx = y * W + x;
  destroyedSet.add(idx);
  log(`Strike (${x}, ${y}) ...`);
  try {
    const r = await fetch(URL + "/strike", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({x, y})
    });
    const state = await r.json();
    strikes++;
    document.getElementById("strikes").textContent = strikes;
    updateGrid(state);
    const densitySlice = state.slice(0, GRID_CELLS);
    log(`  → density[${x},${y}]=${state[idx].toFixed(3)}  min_d=${Math.min(...densitySlice).toFixed(3)}`);
  } catch(e) { log("ERROR: " + e.message); }
  busy = false;
}

async function doHeat(x, y) {
  if (busy) return;
  busy = true;
  const idx = y * W + x;
  log(`Heat (${x}, ${y}) ...`);
  try {
    const r = await fetch(URL + "/heat", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({x, y})
    });
    const state = await r.json();
    heats++;
    document.getElementById("heats").textContent = heats;
    updateGrid(state);
    const thermalVal = state[idx + GRID_CELLS];
    log(`  → thermal[${x},${y}]=${thermalVal.toFixed(3)}`);
  } catch(e) { log("ERROR: " + e.message); }
  busy = false;
}

// --- Tick metronome (Phase 11) ---

async function doTick() {
  if (tickBusy) return;   // previous tick still in-flight
  tickBusy = true;
  try {
    const r = await fetch(URL + "/tick", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: "{}"
    });
    const state = await r.json();
    ticks++;
    document.getElementById("ticks").textContent = ticks;
    updateGrid(state);
  } catch(e) { /* silently skip failed ticks */ }
  tickBusy = false;
}

function startTick() {
  if (tickInterval) return;
  tickInterval = setInterval(doTick, 500);  // 2 ticks/sec
  tickPaused = false;
  document.getElementById("tickToggle").textContent = "Pause Tick";
  document.getElementById("tickStatus").textContent = "⏱ ticking (0.5 s)";
  document.getElementById("tickStatus").className = "tick-active";
}

function stopTick() {
  if (tickInterval) { clearInterval(tickInterval); tickInterval = null; }
  tickPaused = true;
  document.getElementById("tickToggle").textContent = "Resume Tick";
  document.getElementById("tickStatus").textContent = "⏸ paused";
  document.getElementById("tickStatus").className = "tick-paused";
}

function toggleTick() {
  if (tickPaused) startTick(); else stopTick();
}

async function resetGrid() {
  try {
    const r = await fetch(URL + "/reset", {method: "POST"});
    const state = await r.json();
    strikes = 0;
    heats = 0;
    ticks = 0;
    destroyedSet.clear();
    document.getElementById("strikes").textContent = 0;
    document.getElementById("heats").textContent = 0;
    document.getElementById("ticks").textContent = 0;
    updateGrid(state);
    log("--- RESET ---");
  } catch(e) { log("ERROR: " + e.message); }
}

fetchState();
startTick();   // begin background ticking
</script>
</body>
</html>
